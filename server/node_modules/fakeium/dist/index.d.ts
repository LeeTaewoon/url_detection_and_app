import { ExternalCopy, Reference as Reference$1 } from 'isolated-vm';

declare abstract class FakeiumError extends Error {
}
/**
 * Error thrown when a path is malformed or not valid.
 */
declare class InvalidPathError extends FakeiumError {
}
/**
 * Error thrown when a value cannot be serialized inside the sandbox.
 */
declare class InvalidValueError extends FakeiumError {
}
/**
 * Error thrown when a script or module cannot be resolved.
 */
declare class SourceNotFoundError extends FakeiumError {
}
/**
 * Error thrown when the source code of a module could not be parsed.
 */
declare class ParsingError extends FakeiumError {
}
/**
 * Error that encapsulates an uncaught error thrown inside the execution sandbox.
 */
declare class ExecutionError extends FakeiumError {
    /** Original thrown error */
    cause: Error;
    constructor(message: string, cause: Error);
}
/**
 * Error thrown when a script exceeds its maximum execution time.
 */
declare class TimeoutError extends FakeiumError {
}
/**
 * Error thrown when an instance exceeds its maximum allowed memory.
 */
declare class MemoryLimitError extends FakeiumError {
}

/**
 * Class representing a reference to an object inside the sandbox.
 * Does not actually hold the value for the object.
 */
declare class Reference {
    readonly path: string;
    /**
     *
     * @param path Path of value to which redirect events
     */
    constructor(path: string);
}
type Hook = {
    path: string;
    isWritable: boolean;
} & ({
    newPath: string;
} | {
    value: ExternalCopy;
} | {
    function: Reference$1;
});

interface LoggerInterface {
    debug(...args: unknown[]): unknown;
    info(...args: unknown[]): unknown;
    warn(...args: unknown[]): unknown;
    error(...args: unknown[]): unknown;
}
declare class DefaultLogger implements LoggerInterface {
    debug(...args: unknown[]): void;
    info(...args: unknown[]): void;
    warn(...args: unknown[]): void;
    error(...args: unknown[]): void;
}

interface BaseEvent {
    /** Event type */
    type: ReportEvent['type'];
    /** Path to variable that triggered the event (e.g., `navigator.geolocation.getCurrentPosition`) */
    path: string;
    /** Closest location of the code that triggered the event */
    location: Location;
}
interface Location {
    /** Absolute URL to file, including protocol */
    filename: string;
    line: number;
    column: number;
}
type Value = {
    /** Object ID */
    ref: number;
    literal?: never;
} | {
    ref?: never;
    /** Literal value */
    literal: string | number | boolean | null | undefined;
};
interface GetEvent extends BaseEvent {
    type: 'GetEvent';
    value: Value;
}
interface SetEvent extends BaseEvent {
    type: 'SetEvent';
    value: Value;
}
interface CallEvent extends BaseEvent {
    type: 'CallEvent';
    arguments: Value[];
    returns: Value;
    /** Whether call comes from instantiating a new object */
    isConstructor: boolean;
}
type ReportEvent = GetEvent | SetEvent | CallEvent;
type MappedOmit<T, K extends PropertyKey> = {
    [P in keyof T as Exclude<P, K>]: T[P];
};
type Query = Partial<MappedOmit<ReportEvent, 'location'>> & {
    location?: Partial<Location>;
};
/**
 * Helper class for storing and traversing events reported by Fakeium.
 */
declare class Report {
    private readonly events;
    /**
     * Get size
     * @return Current number of events
     */
    size(): number;
    /**
     * Add event
     * @package
     * @param event Event
     */
    add(event: ReportEvent): void;
    /**
     * Clear report
     */
    clear(): void;
    /**
     * Get all events
     * @return Array of events
     */
    getAll(): ReportEvent[];
    /**
     * Find all events that match the given query
     * @param  query Search query
     * @return       Iterable of matched events
     */
    findAll(query: Query): IterableIterator<ReportEvent>;
    /**
     * Find first event that matches the given query
     * @param  query Search query
     * @return       Matched event or `null` if not found
     */
    find(query: Query): ReportEvent | null;
    /**
     * Has event that matches the given query
     * @param  query Search query
     * @return       Whether report has at least one matching event
     */
    has(query: Query): boolean;
    /**
     * Matches value
     * @param  query  Desired value (query)
     * @param  target Target value to check against
     * @return        Whether target value matches query
     */
    private matchesValue;
}

interface FakeiumInstanceOptions {
    /** Type of sources to run (defaults to "script") */
    sourceType?: 'script' | 'module';
    /** Origin to use when resolving relative specifiers (defaults to "file:///") */
    origin?: string;
    /** Maximum amount of memory in MiB that the sandbox is allowed to allocate (defaults to 64MiB) */
    maxMemory?: number;
    /** Maximum execution time in milliseconds for sources (defaults to 10000ms) */
    timeout?: number;
    /** Optional logger instance */
    logger?: LoggerInterface | null;
}
interface FakeiumRunOptions {
    /** Type of source for this particular run */
    sourceType?: 'script' | 'module';
    /** Maximum execution time in milliseconds just for this source */
    timeout?: number;
}
interface FakeiumStats {
    /** Time the sandbox has spent actively doing work on the CPU, in nanoseconds */
    cpuTime: bigint;
    /** Time the sandbox has been running, including passive time, in nanoseconds */
    wallTime: bigint;
    totalHeapSize: number;
    totalHeapSizeExecutable: number;
    totalPhysicalSize: number;
    usedHeapSize: number;
    mallocedMemory: number;
    peakMallocedMemory: number;
    externallyAllocatedSize: number;
}
type SourceCode = Buffer | string;
/**
 * @param  url Absolute URL to source
 * @return     Source code or `null` if not found
 */
type SourceResolver = (url: URL) => Promise<SourceCode | null>;
/**
 * Fakeium (from "Fake" and "Chromium") is a simple yet *safe* instrumented environment for running
 * untrusted JavaScript code that was intended to be run in a web browser.
 *
 * Rather than replacing dynamic analysis, its main goal is to complement static analysis by detecting
 * API calls that would otherwise be missed using traditional AST parsing.
 */
declare class Fakeium {
    private readonly options;
    private resolver;
    private hooks;
    private isolate;
    private readonly pathToModule;
    private readonly moduleToPath;
    private readonly report;
    private readonly stats;
    private nextValueId;
    /**
     * @param options Instance-wide options
     */
    constructor(options?: FakeiumInstanceOptions);
    /**
     * Set source resolver
     * @param resolver Resolver callback
     */
    setResolver(resolver: SourceResolver): void;
    /**
     * Hook value inside sandbox
     *
     * Will overwrite any existing hook for the same path.
     *
     * Allowed values are:
     * - Serializable values that can be copied to the sandbox using the
     *   [structured clone algorithm](https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).
     * - Functions that receive and/or return serializable values. Note that, while the aforementioned values will be
     *   copied from/to the sandbox, functions are executed outside the sandbox.
     * - Instances of {@link Reference} that point to a different value path inside the sandbox.
     *
     * @param path       Path of value to hook
     * @param value      Value to return
     * @param isWritable Whether hook can have its value overwritten inside the sandbox, `true` by default
     * @throws {InvalidPathError} if the provided path is not valid
     * @throws {InvalidValueError} if the provided value is not valid
     */
    hook(path: string, value: unknown, isWritable?: boolean): void;
    /**
     * Unhook value inside sandbox
     * @param path Path of value to unhook
     */
    unhook(path: string): void;
    /**
     * Run code in sandbox
     * @param specifier Specifier
     * @param options   Additional execution options
     * @throws {ExecutionError} if an uncaught error was thrown inside the sandbox
     * @throws {MemoryLimitError} if exceeded max allowed memory for the instance
     * @throws {ParsingError} if failed to parse source code
     * @throws {SourceNotFoundError} if failed to resolve specifier or imports
     * @throws {TimeoutError} if exceeded max execution time
     */
    run(specifier: string, options?: FakeiumRunOptions): Promise<void>;
    /**
     * Run source in sandbox
     * @param specifier  Specifier
     * @param sourceCode JavaScript source code
     * @param options    Additional execution options
     * @throws {ExecutionError} if an uncaught error was thrown inside the sandbox
     * @throws {MemoryLimitError} if exceeded max allowed memory for the instance
     * @throws {ParsingError} if failed to parse source code
     * @throws {SourceNotFoundError} if failed to resolve imports
     * @throws {TimeoutError} if exceeded max execution time
     */
    run(specifier: string, sourceCode: SourceCode, options?: FakeiumRunOptions): Promise<void>;
    /**
     * Get report
     * @return Report instance
     */
    getReport(): Report;
    /**
     * Get stats
     * @return Cumulative summary of stats
     */
    getStats(): {
        /** Time the sandbox has spent actively doing work on the CPU, in nanoseconds */
        cpuTime: bigint;
        /** Time the sandbox has been running, including passive time, in nanoseconds */
        wallTime: bigint;
        totalHeapSize: number;
        totalHeapSizeExecutable: number;
        totalPhysicalSize: number;
        usedHeapSize: number;
        mallocedMemory: number;
        peakMallocedMemory: number;
        externallyAllocatedSize: number;
    };
    /**
     * Dispose instance
     *
     * Frees from memory any resources used by this instance.
     * You should call this method after working with Fakeium to avoid any memory leaks.
     * It *is* safe to reuse the instance after disposing.
     *
     * @param clearReport Whether to clear report as well
     */
    dispose(clearReport?: boolean): void;
    /**
     * Validate path
     * @param path Path
     * @throws {InvalidPathError} if path is not valid
     */
    private validatePath;
    /**
     * Get script
     * @param  specifier  Specifier
     * @param  sourceCode Script source code (overrides resolver)
     * @return            Script instance
     * @throws {SourceNotFoundError} if failed to resolve script
     * @throws {ParsingError} if failed to parse source code
     */
    private getScript;
    /**
     * Get un-instantiated module
     * @param  specifier  Specifier
     * @param  referrer   Referrer module
     * @param  sourceCode Module source code (overrides resolver)
     * @return            Module instance
     * @throws {SourceNotFoundError} if failed to resolve module
     * @throws {ParsingError} if failed to parse source code
     */
    private getModule;
    /**
     * Setup context
     * @param context Execution context
     */
    private setupContext;
    /**
     * Record stats
     * @param isolate Isolate instance
     */
    private recordStats;
}

export { type CallEvent, DefaultLogger, ExecutionError, Fakeium, FakeiumError, type FakeiumStats, type GetEvent, type Hook, InvalidPathError, InvalidValueError, type Location, type LoggerInterface, MemoryLimitError, ParsingError, Reference, Report, type ReportEvent, type SetEvent, SourceNotFoundError, TimeoutError, type Value };
