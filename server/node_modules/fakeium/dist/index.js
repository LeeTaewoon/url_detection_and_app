import { readFileSync } from 'fs';
import ivm from 'isolated-vm';

class FakeiumError extends Error {
  // Intentionally left blank
}
class InvalidPathError extends FakeiumError {
  // Intentionally left blank
}
class InvalidValueError extends FakeiumError {
  // Intentionally left blank
}
class SourceNotFoundError extends FakeiumError {
  // Intentionally left blank
}
class ParsingError extends FakeiumError {
  // Intentionally left blank
}
class ExecutionError extends FakeiumError {
  /** Original thrown error */
  cause;
  constructor(message, cause) {
    super(message);
    this.cause = cause;
  }
}
class TimeoutError extends FakeiumError {
  // Intentionally left blank
}
class MemoryLimitError extends FakeiumError {
  // Intentionally left blank
}

class Reference {
  path;
  /**
   *
   * @param path Path of value to which redirect events
   */
  constructor(path) {
    this.path = path;
  }
}

class DefaultLogger {
  debug(...args) {
    console.debug(...args);
  }
  info(...args) {
    console.log(...args);
  }
  warn(...args) {
    console.warn(...args);
  }
  error(...args) {
    console.error(...args);
  }
}

class Report {
  events = [];
  /**
   * Get size
   * @return Current number of events
   */
  size() {
    return this.events.length;
  }
  /**
   * Add event
   * @package
   * @param event Event
   */
  add(event) {
    this.events.push(event);
  }
  /**
   * Clear report
   */
  clear() {
    this.events.length = 0;
  }
  /**
   * Get all events
   * @return Array of events
   */
  getAll() {
    return this.events;
  }
  /**
   * Find all events that match the given query
   * @param  query Search query
   * @return       Iterable of matched events
   */
  *findAll(query) {
    for (const event of this.getAll()) {
      if (query.type !== void 0 && query.type !== event.type) {
        continue;
      }
      if (query.path !== void 0 && query.path !== event.path) {
        continue;
      }
      if (query.location?.filename !== void 0 && query.location.filename !== event.location.filename) {
        continue;
      }
      if (query.location?.line !== void 0 && query.location.line !== event.location.line) {
        continue;
      }
      if (query.location?.column !== void 0 && query.location.column !== event.location.column) {
        continue;
      }
      if ("value" in query && query.value && (!("value" in event) || !this.matchesValue(query.value, event.value))) {
        continue;
      }
      if ("arguments" in query && query.arguments) {
        if (!("arguments" in event) || query.arguments.length === 0 && event.arguments.length !== 0) {
          continue;
        }
        let matches = true;
        for (const queryArg of query.arguments) {
          matches = false;
          for (const eventArg of event.arguments) {
            if (this.matchesValue(queryArg, eventArg)) {
              matches = true;
              break;
            }
          }
          if (!matches) {
            break;
          }
        }
        if (!matches) {
          continue;
        }
      }
      if ("returns" in query && query.returns && (!("returns" in event) || !this.matchesValue(query.returns, event.returns))) {
        continue;
      }
      if ("isConstructor" in query && (!("isConstructor" in event) || query.isConstructor !== event.isConstructor)) {
        continue;
      }
      yield event;
    }
  }
  /**
   * Find first event that matches the given query
   * @param  query Search query
   * @return       Matched event or `null` if not found
   */
  find(query) {
    return this.findAll(query).next().value || null;
  }
  /**
   * Has event that matches the given query
   * @param  query Search query
   * @return       Whether report has at least one matching event
   */
  has(query) {
    return this.find(query) !== null;
  }
  /**
   * Matches value
   * @param  query  Desired value (query)
   * @param  target Target value to check against
   * @return        Whether target value matches query
   */
  matchesValue(query, target) {
    if (query.ref !== void 0 && query.ref !== target.ref) {
      return false;
    }
    if ("literal" in query && (!("literal" in target) || query.literal !== target.literal)) {
      return false;
    }
    return true;
  }
}

const PATH_PATTERN = /^[a-z_$][a-z0-9_$]*(\.[a-z_$][a-z0-9_$]*|\[".+?"\]|\['.+?'\]|\[\d+\])*$/i;
const BOOTSTRAP_CODE = readFileSync(new URL("bootstrap.js", import.meta.url), "utf-8");
class Fakeium {
  options;
  resolver = async () => null;
  hooks = /* @__PURE__ */ new Map();
  isolate = null;
  pathToModule = /* @__PURE__ */ new Map();
  moduleToPath = /* @__PURE__ */ new Map();
  report = new Report();
  stats = {
    cpuTime: 0n,
    wallTime: 0n,
    totalHeapSize: 0,
    totalHeapSizeExecutable: 0,
    totalPhysicalSize: 0,
    usedHeapSize: 0,
    mallocedMemory: 0,
    peakMallocedMemory: 0,
    externallyAllocatedSize: 0
  };
  nextValueId = 1;
  /**
   * @param options Instance-wide options
   */
  constructor(options = {}) {
    this.options = {
      sourceType: "script",
      origin: "file:///",
      maxMemory: 64,
      timeout: 1e4,
      logger: null,
      ...options
    };
    for (const path of ["frames", "global", "parent", "self", "window"]) {
      this.hook(path, new Reference("globalThis"));
    }
    this.hook("document", {
      nodeType: 9,
      // Node.DOCUMENT_NODE
      readyState: "complete"
    });
    this.hook("browser", {});
    this.hook("chrome", new Reference("browser"));
    for (const path of ["define", "exports", "module", "require"]) {
      this.hook(path, void 0);
    }
  }
  /**
   * Set source resolver
   * @param resolver Resolver callback
   */
  setResolver(resolver) {
    this.resolver = resolver;
  }
  /**
   * Hook value inside sandbox
   *
   * Will overwrite any existing hook for the same path.
   *
   * Allowed values are:
   * - Serializable values that can be copied to the sandbox using the
   *   [structured clone algorithm](https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).
   * - Functions that receive and/or return serializable values. Note that, while the aforementioned values will be
   *   copied from/to the sandbox, functions are executed outside the sandbox.
   * - Instances of {@link Reference} that point to a different value path inside the sandbox.
   *
   * @param path       Path of value to hook
   * @param value      Value to return
   * @param isWritable Whether hook can have its value overwritten inside the sandbox, `true` by default
   * @throws {InvalidPathError} if the provided path is not valid
   * @throws {InvalidValueError} if the provided value is not valid
   */
  hook(path, value, isWritable = true) {
    this.validatePath(path);
    if (value instanceof Reference) {
      this.validatePath(value.path);
      this.hooks.set(path, {
        path,
        isWritable,
        newPath: value.path
      });
    } else if (typeof value === "function") {
      this.hooks.set(path, {
        path,
        isWritable,
        function: new ivm.Reference(value)
      });
    } else {
      try {
        this.hooks.set(path, {
          path,
          isWritable,
          value: new ivm.ExternalCopy(value)
        });
      } catch (e) {
        throw new InvalidValueError(e.message);
      }
    }
  }
  /**
   * Unhook value inside sandbox
   * @param path Path of value to unhook
   */
  unhook(path) {
    this.hooks.delete(path);
  }
  async run(specifier, b, c) {
    let sourceCode = void 0;
    let options;
    if (typeof b === "string" || b instanceof Buffer) {
      sourceCode = b;
      options = c || {};
    } else {
      options = b || {};
    }
    const timeout = options.timeout ?? this.options.timeout;
    const sourceType = options.sourceType || this.options.sourceType;
    if (this.isolate === null) {
      this.isolate = new ivm.Isolate({
        memoryLimit: this.options.maxMemory
      });
    }
    const context = await this.isolate.createContext();
    await this.setupContext(context);
    let scriptOrModule;
    if (sourceType === "script") {
      scriptOrModule = await this.getScript(specifier, sourceCode);
    } else {
      scriptOrModule = await this.getModule(specifier, void 0, sourceCode);
      await scriptOrModule.instantiate(context, (specifier2, referrer) => this.getModule(specifier2, referrer));
    }
    let didTimeout = false;
    const hardTimeout = setTimeout(() => {
      this.options.logger?.warn("Script refused to stop, terminating it");
      didTimeout = true;
      this.recordStats();
      this.dispose(false);
    }, timeout + 150);
    try {
      if ("evaluate" in scriptOrModule) {
        await scriptOrModule.evaluate({ timeout });
      } else {
        await scriptOrModule.run(context, { timeout });
      }
    } catch (e) {
      if (!(e instanceof Error)) {
        this.options.logger?.warn(`Expected Error from sandbox, received ${typeof e}`);
        throw e;
      }
      if (e.message === "Script execution timed out.") {
        didTimeout = true;
      } else if (e.message === "Isolate was disposed during execution") {
        this.options.logger?.debug("Forcedly disposed instance to terminate script");
      } else if (e.message === "Isolate was disposed during execution due to memory limit") {
        this.dispose(false);
        throw new MemoryLimitError(`Exceeded ${this.options.maxMemory}MiB memory limit`);
      } else {
        throw new ExecutionError("Uncaught error raised in sandbox", e);
      }
    } finally {
      clearTimeout(hardTimeout);
      if (this.isolate !== null) {
        this.recordStats();
      }
      context.release();
    }
    if (didTimeout) {
      throw new TimeoutError(`Exceeded ${timeout}ms timeout`);
    }
  }
  /**
   * Get report
   * @return Report instance
   */
  getReport() {
    return this.report;
  }
  /**
   * Get stats
   * @return Cumulative summary of stats
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Dispose instance
   *
   * Frees from memory any resources used by this instance.
   * You should call this method after working with Fakeium to avoid any memory leaks.
   * It *is* safe to reuse the instance after disposing.
   *
   * @param clearReport Whether to clear report as well
   */
  dispose(clearReport = true) {
    this.pathToModule.clear();
    this.moduleToPath.clear();
    if (this.isolate !== null) {
      try {
        this.isolate.dispose();
      } catch (_) {
        this.options.logger?.debug("Attempted to dispose a previously disposed isolate, ignored");
      }
      this.isolate = null;
    }
    if (clearReport) {
      this.report.clear();
      this.nextValueId = 1;
    }
    if (clearReport) {
      this.stats.cpuTime = 0n;
      this.stats.wallTime = 0n;
      this.stats.totalHeapSize = 0;
      this.stats.totalHeapSizeExecutable = 0;
      this.stats.totalPhysicalSize = 0;
      this.stats.usedHeapSize = 0;
      this.stats.mallocedMemory = 0;
      this.stats.peakMallocedMemory = 0;
      this.stats.externallyAllocatedSize = 0;
    }
  }
  /**
   * Validate path
   * @param path Path
   * @throws {InvalidPathError} if path is not valid
   */
  validatePath(path) {
    if (!PATH_PATTERN.test(path)) {
      throw new InvalidPathError(`Path "${path}" is not valid`);
    }
  }
  /**
   * Get script
   * @param  specifier  Specifier
   * @param  sourceCode Script source code (overrides resolver)
   * @return            Script instance
   * @throws {SourceNotFoundError} if failed to resolve script
   * @throws {ParsingError} if failed to parse source code
   */
  async getScript(specifier, sourceCode) {
    const url = new URL(specifier, this.options.origin);
    if (sourceCode === void 0) {
      sourceCode = await this.resolver(url) ?? void 0;
      if (sourceCode === void 0) {
        throw new SourceNotFoundError(`Cannot find script "${specifier}": failed to resolve absolute URL ${url.href}`);
      }
    }
    if (this.isolate === null) {
      throw new ReferenceError("Illegal state: missing isolate when getting script");
    }
    let script;
    try {
      script = this.isolate.compileScriptSync(`${sourceCode}`, { filename: url.href });
    } catch (e) {
      if (e instanceof SyntaxError) {
        throw new ParsingError(e.message);
      }
      throw e;
    }
    this.options.logger?.debug(`Compiled script ${url.href}`);
    return script;
  }
  /**
   * Get un-instantiated module
   * @param  specifier  Specifier
   * @param  referrer   Referrer module
   * @param  sourceCode Module source code (overrides resolver)
   * @return            Module instance
   * @throws {SourceNotFoundError} if failed to resolve module
   * @throws {ParsingError} if failed to parse source code
   */
  async getModule(specifier, referrer, sourceCode) {
    const relativeTo = referrer ? this.moduleToPath.get(referrer) : void 0;
    const url = new URL(specifier, relativeTo || this.options.origin);
    let cachedModule = this.pathToModule.get(url.href);
    if (cachedModule && sourceCode !== void 0) {
      this.options.logger?.warn(`Overwriting cached module ${url} with custom source code`);
      cachedModule.release();
      cachedModule = void 0;
    }
    if (cachedModule) {
      return cachedModule;
    }
    if (sourceCode === void 0) {
      sourceCode = await this.resolver(url) ?? void 0;
      if (sourceCode === void 0) {
        throw new SourceNotFoundError(`Cannot find module "${specifier}": failed to resolve absolute URL ${url.href}`);
      }
    }
    if (this.isolate === null) {
      throw new ReferenceError("Illegal instance state: missing isolate");
    }
    let module;
    try {
      module = this.isolate.compileModuleSync(`${sourceCode}`, { filename: url.href });
    } catch (e) {
      if (e instanceof SyntaxError) {
        throw new ParsingError(e.message);
      }
      throw e;
    }
    this.pathToModule.set(url.href, module);
    this.moduleToPath.set(module, url.href);
    this.options.logger?.debug(`Compiled module ${url.href}`);
    return module;
  }
  /**
   * Setup context
   * @param context Execution context
   */
  async setupContext(context) {
    const logEvent = (event, nextValueId) => {
      this.report.add(event);
      this.nextValueId = nextValueId;
    };
    const logDebug = (...args) => this.options.logger?.debug("<SANDBOX>", ...args);
    const awaitReference = async (ref) => {
      let value = ref.deref();
      if (value instanceof Promise) {
        value = await value;
      }
      return new ivm.Reference(value);
    };
    await context.evalClosure(
      BOOTSTRAP_CODE,
      [
        this.nextValueId,
        // $0
        logEvent,
        // $1
        logDebug,
        // $2
        awaitReference,
        // $3
        Array.from(this.hooks.values())
        // $4
      ],
      {
        arguments: {
          reference: true
        }
      }
    );
  }
  /**
   * Record stats
   * @param isolate Isolate instance
   */
  recordStats() {
    if (this.isolate === null) {
      throw new ReferenceError("Illegal state: missing isolate when recording stats");
    }
    const heap = this.isolate.getHeapStatisticsSync();
    this.stats.cpuTime += this.isolate.cpuTime;
    this.stats.wallTime += this.isolate.wallTime;
    this.stats.totalHeapSize += heap.total_heap_size;
    this.stats.totalHeapSizeExecutable += heap.total_heap_size_executable;
    this.stats.totalPhysicalSize += heap.total_physical_size;
    this.stats.usedHeapSize += heap.used_heap_size;
    this.stats.mallocedMemory += heap.malloced_memory;
    this.stats.peakMallocedMemory = Math.max(this.stats.peakMallocedMemory, heap.peak_malloced_memory);
    this.stats.externallyAllocatedSize += heap.externally_allocated_size;
  }
}

export { DefaultLogger, ExecutionError, Fakeium, FakeiumError, InvalidPathError, InvalidValueError, MemoryLimitError, ParsingError, Reference, Report, SourceNotFoundError, TimeoutError };
